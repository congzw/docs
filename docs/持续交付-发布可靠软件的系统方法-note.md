# 持续交付-发布可靠软件的系统方法

## 摘要

本书包括三部分

- 基础（讲述基本原则和与其相关的实践）
	- 第01章 常见反模式，目标以及实现方式，总结软件交付的一些原则。
	- 第02章 阐述了管理构建、部署、测试和发布应用程序所需的一些要素，包括源代码、构建脚本，以及环境和应用程序配置。
	- 第03章 讲述了在程序每个变更后执行构建和运行自动化测试相关的实践，以便确保你的软件一直处于可工作状态。
	- 第04章 介绍了每个项目中的各种手工和自动化测试，并讨论了如何确定适合自己项目的策略。
- 部署流水线（讲述部署流水线及其各个阶段）
	- 第05章 介绍了一种模式，即本书的核心——每次代码修改后从提交到发布的一个自动化过程。我们也讨论了如何在团队级别和组织级别实现流水线。
	- 第06章 脚本以及最佳实践。
	- 第07章 讨论了部署流水线中的第一个阶段，即提交阶段。
	- 第08章 展现了从分析一直到实现的自动化验收测试。
	- 第09章 讨论了非功能需求，并重点介绍了容量测试。
	- 第10章 讲述自动化测试之后应做什么：一键式将候选发布版本部署到手工测试环境、用户验收测试环境、试运行环境，直至最终发布。其中包括一些至关重要的主题， 如持续部署、回滚以及零停机发布。
- 交付生态圈（深入分析支撑持续交付的生态系统）
	- 第11章 的内容包括环境的自动化创建、管理和监控，包括虚拟化技术和云计算的使用。
	- 第12章 讨论了在应用程序的生命周期中，如何创建和迁移测试数据和生产数据。
	- 第13章首先讨论了如何在不使用分支的情况下让应用程序一直处于可发布状态。然后描述了如何将应用程序分解成多个组件，以及如何建立和测试这些组件。
	- 第14章 概述了最流行的一些工具，以及使用版本控制的不同模式。
	- 第15章 风险管理和符合度，并提出了配置和发布管理的一个成熟度模型。然后，我们讨论了持续交付带来的商业价值，和迭代增量交付项目的生命周期。

持续交付：

CI只是第一步。软件即使被成功地集成到了代码主干上，也仍旧是没有在生产环境中发挥作用的软件。持续交付解决从CI至“最后一公里”的问题，通过构建部署流水线，将已集成的代码转变为已部署到生产环境中的软件。

至少对开发团队来说，该方法的基础是持续集成（CI）。CI使整个开发团队保持同步，消除了集成问题引起的延期。在几年前，Paul  Duvall写了一本关于CI的书。但CI只是第一步。软件即使被成功地集成到了代码主干上，也仍旧是没有在生产环境中发挥作用的软件。对从CI至“最后一公里”的问题进行了阐述，描述了如何构建部署流水线，才能将已集成的代码转变为已部署到生产环境中的软件。
这种交付思想长期以来一直是软件开发中被人遗忘的角落，是开发人员和运维团 队之间的一个黑洞。因此毫无疑问的是，本书中的技术都依赖于这些团队的凝聚，而 这也就是悄然兴起的DevOps运动的前兆。这个过程也包括测试人员，因为测试工作也 是确保无差错发布的关键因素。贯穿一切的是高度自动化，让事情能够很快完成而且 没有差错。
为了实现这些，需要付出努力，但所带来的好处是意义深远的。持续时间长且强 度很高的发布将成为过去。软件客户能够看到一些想法快速变成他们可以每天使用的 可工作软件。也许最重要的是，我们消除了软件开发中严重压力的一个重大来源。没 有人喜欢为了让系统升级包能够在周一的黎明前发布而在周末紧张加班。
在我看来，如果有这样一本书，能够告诉你如何做到无压力且频繁地交付软件， 那么显然它是值得一读的。考虑到你们团队的利益，我希望你能同意我的观点。


## 1 软件交付的问题


构建、部署、测试、发布


### 部署流水线

部署流水线以CI为理论基石，目标有3：

- 让过程对所有人可见
- 促进反馈，及时发现和解决问题
- 以自动化的方式随时发布任意版本

定义：

部署流水线就是指一个应用程序，从构建、部署、测试到发布这整个过程的自动化实现。部署流水线的实现，对每个组织都是不同的，这取决于他们对软件发布的价值流的定义，但背后的原则是相同的。

“对应用程序的任何变更，会触发一个新的流水线的实例”

### 发布反模式

- 手工部署（手工密集型的发布工作）
- 开发完才向类生产环境部署（不良协作、错误假设）
- 手工配置（禁止手工改变环境，包括生产环境，而是采用自动化支持）

>...软件发布能够（也应该）成为一个低风险、频繁、廉价、迅速且可预见的过程。...

集群部署形态与文件系统、缓存系统、流媒体服务等的问题
不但对应用程序进行测试，而且对部署过程进行测试


自动化部署，应该只做两件事：
1 挑选版本和需要部署的环境
2 按一下“部署”按钮

### 软件从业者的目标

快速交付可靠的软件

我们需要找到一种可以高效、快速、可靠的交付高质量且有价值软件的方法（短周期，高质量）。

频繁自动化的发布，意味着反馈很重要。关于反馈的三个标准：

- 总是触发（任何修改都要触发反馈流程）
- 快速反馈
- 快速反应（交付团队必须接受反馈，并且快速反应）

### 持续交付的好处

- 授权的团队（自服务的测试、运维、开发）
- 减少错误（手工 VS 自动化）
- 缓解压力
- 灵活的部署

### 候选发布版

传统的候选发布版 VS 持续集成的随时可发布

Pre-alpha, Alpha, Beta, Candidate, Gold
每次提交都可以发布！

### 软件交付的原则

- 为软件发布创建可重复且可靠的过程
- 尽可能的自动化
- 把所有东西纳入版本控制
- 提前并频繁地做让你感到痛苦的事（持续发布，持续改进）
- 内建质量（测试越早越好，所有人都参与）
- “完成”意味着已发布
- 交付过程是每个成员的责任
- 持续改进

> 我们还能与家人和朋友共度周末，享受没有压力的生活，而工作也会变得更加高效。……

## 2 配置管理

本书中的定义：

配置管理是指一个过程，通过该过程，所有项目相关的产物，以及它们之间的关系都被唯一定义、修改、存储和检索。

版本控制仅仅是制定配置管理策略的第一步。

- 能否再现需要的任何环境？
- 能否能增量式修改，并将修改部署到任意环境中？
- 能否轻松追溯到所有的修改细节
- 每个人都很容易的得到


记录了系统以及应用程序的演进过程
对团队成员协作方式的管理

配置管理将：

- 为管理构建、部署、测试、发布的过程做好准备（对内容进行版本控制，对它们的依赖关系进行管理）
- 管理配置信息
- 管理环境（软、硬、基础设施）

### 使用版本控制

版本控制的两个目的：

- 追溯
- 协作

version control > source control

- 将所有的资产纳入版本控制库
- 频繁提交到主干
- 使用有意义的注释

多个分支开发的一些问题（14章中有更详细的介绍）：

- 违背了持续集成的宗旨（推迟了集成的时间）
- 合并复杂
- 增大重构的困难（多分支，多文件，合并更加困难）

> 但在主线没有持续集成支持的情况下，目前的发版分支策略，我认为是较好的过渡选择，但终归，拥抱持续集成才是正路。

### 依赖管理（13章有更详细的介绍）

外部库 VS 组件、模块

外部库文件管理(nuget)
组件管理(nuget vs project)

> 我们选择时要权衡的问题：稳定和兼容性！
> ...随着系统不断变大，或当有其他项目依赖于我们开发的组件时，我们就需要将这几个组件的构建分成不同的构建流水线了。如果你正是这么干的，需要特别注意一点就是，这些构建流水线之间的依赖应该是二进制依赖，而不是源代码依赖。因为...


### 软件配置管理

终极可配置的平衡游标

- 分析瘫痪
- 得不偿失

> ...“修改配置的风险比修改代码的风险低”这句话就是个错觉...
> ...配置不是天生邪恶，但需要谨慎的对待...

配置的分类

- 构建时写入二进制
- 打包时放入软件包
- 安装时获取或要求用户输入
- 启动或运行时获取

通常不赞同在构建或打包时植入。

应用配置管理
跨应用配置管理

管理配置信息的原则

### 环境管理

管理工具
变更过程管理

### 小结

配置管理是持续集成、发布管理、部署流水线的基础。

## 3 持续集成

参见《持续集成》

持续集成之前要做的准备：

- 版本控制
- 自动化构建
- 团队共识

持续集成不是工具，而是实践（你不一定需要一个持续集成软件）。

持续集成的前提条件

- 频繁提交到主干
- 全面自动化测试
- 保持快速构建
- 管理开发工作区

### 使用持续集成软件

### 必不可少的实践

构建失败不要更新代码
先私有构建
测试通过后再继续工作
回家之前，构建必须成功
时刻准备着回滚到前一版本
回滚之前要规定一个修复之间
不要把失败的注释注释掉
为自己的问题负责
测试驱动开发

### 推荐的实践

XP
违背架构原则，就让构建失败
测试运行慢，就让构建失败
便已经高或代码风格有问题，就让构建失败

### 分布式团队

持续集成需要团队纪律支持。

## 4 测试策略的实现

## 5 部署流水线

### 引言

对于大多数项目来说，采纳持续集成实践就是向高效率和高质量迈进的一大步。它保证那些创建大型复杂系统的团队具有高度的自信心和控制力。
一旦代码提交引入了问题，持续集成就能为我们提供快速反馈。它主要关注于代码是否可以编译成功，以及是否可以通过单元测试和验收测试。但持续集成不足以满足我们的需要。

持续集成主要关注的对象是开发团队，其输出作为测试和运维环节的输入。

一键部署到（类）生产环境

从精益的角度讲，我们实现了一个“pull system”。整个交付过程中所有人都有两种能力，即能用任何想要使用的东西，也能看到整个发布流程。

### 部署流水线

从某种抽象层次讲，部署流水线是指软件从版本控制库到用户手中的这一过程的自动化表现。


构建失败，将不会进入下一个阶段。部署流水线纪律。
部署和发布自动化，如果支持自动安全回滚，发布风险也大大降低，频繁发布就更不是问题了。（第十章）
为了达到这种状态，必须将业务测试自动化，还要把部署过程自动化。

提交阶段
自动化验收测试
手工测试
发布阶段


发布阶段旨在将软件交付用户，既可能是套装软件的形式，也可能直接部署到生产坏境。


### 部署流水线相关实践

- 只生成一次二进制包
- 对不同环境采用同一部署方式
- 对部署进行冒烟测试
- 向生产环境的副本中部署
- 每次变更都要立刻在流水线中传递
- 只要环节失败，就立刻停止流水线

### 提交阶段

编译代码
运行一套提交测试
创建二进制包
执行代码分析
为后续阶段做准备，例如数据库准备

提交阶段的最佳实践（第三章）

### 自动化测试

单元测试和API是紧耦合的，以至于开发人员难免落入一个陷阱，即“用某种特殊方式证明解决方案是正确的，而不是断言它解决了某个具体问题”


### 后续测试

手动测试
非功能测试（第九章）

### 发布准备

自动部署和发布
变更撤销

### 实现部署流水线

从无到有或从现有改造，都建议采取增量策略

对价值流建模，创建一个可工作的简单框架
将构建和部署自动化
将单元测试和代码分析自动化
将验收测试自动化
将发布自动化

### 度量

度量什么？

整体做优化而不是局部
周期时间。

### 小结

部署流水线的目的是，让软件交付过程中的每个人都能看到每个构建版本提交到发布的整个过程。


构建 -> 测试 -> 发布 


## 6 构建与部署的脚本化

### 引言

### 构建工具概览

### 构建部署脚本的原则和实践

- 脚本化流水线
- 使用恰当的部署程序
- 使用同样的脚本向所有环境部署
- 使用系统自带的包管理工具
- 确保部署流程幂等
- 部署系统的增量式演进

### JVM（CLR）

源代码管理
测试管理
构建输出管理
库文件管理

### 部署脚本化


## 7 提交阶段

## 8 自动化验收测试


## 9 非功能需求的测试

容量，吞吐量，新功能

## 10 应用程序的部署与发布

## 11 基础设施和环境管理

## 12 数据管理

## 13 组件和依赖管理

### 引言

本章的内容，依赖于对部署流水线有个很好的理解（第五章）

> ...然而，在大型重构或添加复杂功能的时候又该怎么办呢？从版本库拉一个新分支，看上去好像是解决这个问题的一个方案。但我们强烈感觉这是个错误的做法。……一项关键的技术，就是*大型应用程序的组件化*


什么是组件（模块）？
组件，是指应用程序中的一个规模相当大的代码结构，具有一套定义良好的API，可以被另一种实现方式代替。

基于组件的系统 VS 铁板一块的系统

- 清晰地边界（关注点分离，有良好的封装，松耦合，迪米特法则）
- 组件与语言和技术无关，可以是dll，jar，so(.net, java, unix)

基于组件的架构设计：

- 可重用
- 大团队的协作

对于小项目的忠告：

> 很多项目最终陷入了无法维护的代码泥潭，因为在很容易做组件分离的阶段，却没有人打算创建分离式的组件。然后小项目会逐渐变成大项目！

构建系统的是三个维度：部署流水线，分支和组件。在大型项目中，这三个维度常常同时出现。

组件的适配： “打地鼠”游戏

### 保持应用程序可发布

持续集成：保证可用性。
部署流水线（持续集成的扩展，最终的目标）：保证可发布。
它们二者都依赖于一件事，即主干开发模式。在云平台演进中，主题的引入，是一个用技术策略，修正分支滥用的非常典型的例子。

主干开发模式的4种策略应对：

- 隐藏新功能，直到完成为止
	- 把半成品和系统一起发布是一个好实践，因为它表明你一直在集成并测试整个系统。
	- 这种开发方式，需要一定的计划工作，细心地架构和严格的开发纪律
- 所有变更都变成一系列增量小修改，每次小修改都是可发布的
	- 改动越大，合并的难度就越大，就越不应该分支。
	- 分成小步增量，也意味着可以随时停下当前的工作，避免做到一半不得不放弃的浪费。
- 使用抽象模拟分支的方式应对代码库的大范围变更（增量太困难）
	- 在要修改的那部分代码上，创建抽象层。
	- 重构系统其他部分，让它使用这个抽象层。
	- 创建一种新的实现代码，在它完成前，不要将其作为代码产品的一部分
	- 更新抽象层，让它使用这个新的代码实现
	- 移除原来的实现代码
	- 如果不需要抽象层，就移除它
	- 策略模式或依赖注入可以帮忙，但关键是如何找到那个合适的“缝隙”
- 使用组件，根据不同的修改频率进行解耦（转化为组件的时候，抽象模拟策略也可帮上忙）

>...当做较大改动时，拉分支并修改完成后再合并，以便提高效率。但是事实上，最后的合并往往是最困难的部分，改动越大，合并难度就越大。分支理由越明显，越不应该分支。

>...进行大范围修改，如果有全面的自动化验收测试，一定会取得巨大的收益，因为单元测试和组件测试的粒度都太小，不足以对业务功能形成保。

注意，全面的自动化测试是能顺利开展下去的重要的保障。

### 依赖

组件（component）VS库（library）

- 库是指那些只有选择权，没有控制权的软件包，通常很少更新。
- 组件通常是自己团队开发的，通常更新频繁。

构建时依赖 VS 运行时依赖

- 构建时依赖会出现在编译和链接时
- 运行时依赖会出现在运行时

两种管理库的可行方法：

- 提交到版本库（建议库文件加版本号）
- 显示声明，借助于库管理工具管理

### 组件

组件可以独立部署，类通常不能算做组件。

我们讲一个系统分成多个组件的目标是提高整个团队的效率。原因如下：

- 将问题分为更小更达意的代码块
- 不同组件的变化率不同，生命周期不同
- 它鼓励我们使用清晰地职责和边界来设计和维护软件
- 它提供了额外的自由度来优化构建和部署过程

将组件从代码库分离出来的理由：

- 代码库的一部分需要独立部署（服务器或富客户端）
- 打算将系统分为内核和系列组件，以便替换或扩展
- 组建为其他系统提供接口（比如提供API框架或服务）
- 代码编译和链接的时间太长
- 开发环境打开项目时间太长
- 对于一个团队，代码库太大

后三条理由看上去很主观，但确是正当理由，尤其最后一点。（合理划分代码库的范围，可以让整个团队处于最佳状态。）

> 我们不建议让每个团队各自负责一个独立的组件，因为大多数情况下，需求不会按组件的边界来分，这样的划分使工作不高效，也容易形成筒仓效应（silo），从而失去全局性视角。

>...当然过分组件化，即没有充分理由的组件化，应该避免。两个极端都不恰当。权衡依旧靠经验，软件开发既是一门工程学，又是一门艺术、手艺活社会学。

使用组件不一定要使用N层架构，二者不是同义词，二者应该是正交关系。

> 最后，要注意的是康威法则，即“设计系统的组织不可避免地要产生与其组织沟通结构一样的设计”。

虽然在开发应用程序时应该分成几个组件，但不一定需要创建多个构建流水线。现实场景下，有时系统会受益于区分成不同的构建流水线：

- 应用程序某些部分有不同的生命周期
- 应用程序的几个领域是不同的团队（可能是分布式）负责
- 某些组件使用不同的技术或构建流程
- 某些共享组件被不同的几个项目使用
- 组件相对稳定，不需要频繁修改
- 全面构建整个系统的时间太长

一般性的指导原则：

尽量让需要管理的构建数量最小化，一个优于两个，两个优于三个，以此类推。

参照目前公司的规模和产品复杂度，应尽力避免这些构建网格的多条流水线的思路。应慎重考虑云平台基础库的构建流水线方式。

### 管理依赖关系图

todo 对云平台目前的依赖关系进行梳理

### 产出物管理（二进制包）

利用文件系统来管理二进制包
制品库

### 使用工具管理依赖（nuget）

### 小结

本章讨论了既能让程序一直处于可发布状态，又尽可能让团队高效开发的技术。原则就是确保团队尽快得到修改代码后产生的影响。增量和组件化是两种有效的策略。


## 14 版本控制进阶

### 引言

版本控制系统的两个作用：

- 追溯
- 协作

### 版本控制历史

分支的合理理由：

- 为了发布应用程序的一个新版本（bug修复）
- 当需要调研一个新功能，或做一次重构时（分支最终会被丢弃）
- 需要对应用程序做较大的修改，但无法使用其他方法避免分支时（短周期分支）

建议放弃悲观锁

### 分支与合并

从精益的角度来讲，分支上的工作就是浪费，即它们是库存，因为没有被放到最终的产品里去。

> 值得再次强调的是，你根本不应该使用长生命周期且不频繁合并的分支，作为管理大型项目的首选方式。版本控制系统仅仅是工具，无法改变这些高风险活动的性质。
> ...我们强烈推荐，可以说是业界标准，只为发布创建长周期分支...
> ...在大型项目中，如果很多人常常要修改一处代码，这表明代码的结构很差，缺乏良好的封闭性，耦合性高...

### 主干开发

> 实际上，主干开发是一个及其有效的开发方法，也是唯一使你能执行持续集成的方法。

主干开发有三个好处：

- 确保所有代码被持续集成
- 确保开发人员及时获得他人修改
- 避免项目后期的“合并地狱”和“集成地狱”

主干开发并不排斥分支。更确切地说，它意味着“所有开发活动在某一时间点都会以单一代码基线而告终”。


> 简而言之，所面临的问题正是持续集成应该解决的问题。创建长生命周期的分支，与成功的持续集成策略背道而驰。

### 按发布创建分支

为发布创建分支，取代了为了发布而“冻结代码”的邪恶做法。

一旦创建了这个分支，该发布的测试和验证全都在该分支上进行，而新的开发工作依旧在主干上进行。

这种模式遵循以下规则：

- 一直在主干上开发新功能
- 当待发布版本的所有功能都完成，且希望继续开发新功能才创建一个分支
- 分支上仅允许提交修复缺陷的代码，并且这些修改必须立即合并回主干
- 当执行实际的发布时，这个分支可以选择性的打一个标签

使用“安发布创建分支”的方式时，有一点非常重要，就是不要在已有的发布分支上，再创建更多的分支。所有的后续分支，都应该是从主干上创建的。

一旦发布频率达到一定频度（例如一周一次），那么按发布创建分支的策略就没有必要了。在这种情况下，发布一个新版本，比现在已发布的分支上打补丁更容易，成本更低。

### 按功能特性分支

> 我们谨慎的态度推荐这种策略，因为它是一种“在刀尖上跳舞”的反模式，它与持续集成是对立的。开发人员通过特性来创建分支，而这分支会独立很长时间，只有接近发布时，才被合并。参见马丁的“安特性分支”的风险一文。（开源项目的协作，经常采用这种方式）

### 按团队分支

类似于按特性分支。

### 小结

“在软件开发的过程中能够对所创建和依赖的资产进行有效的控制”这一点，对任何项目的成功都很重要。

版本控制模式非常关键，很差的版本控制实践是“快速低风险发布”的最常见阻碍之一。拿到合适的工具，并正确的使用它，是成功软件项目的一个重要特征。

持续集成和创建分支，这两者的愿望从根本上就有一种张力。在使用持续集成做软件开发时，一旦你决定创建分支，就是在一定程度上做出了妥协。到底使用哪种分支模式，应先识别出对团队和软件项目来说，最优的流程，然后在此基础上，再做出选择。

一方面，从持续集成的角度来说：每次修改都应该尽早的提交到主干，间隔时间越长，合并的风险就越高。另一方面，存在某些因素让使用分支可能会更高效一些。本章讨论了一定程度妥协的备选方法，然后很重要的一点是，每次创建分支，都要意识到它带来的成本，无论什么理由创建了分支，都要努力保证任何活跃分支每天（甚至更频繁地）合并回主干。不这么做，就不是真正的持续集成。

因此，我们推荐使用分支而无需说明的唯一情况是：为了发布或技术调研创建分支，以及在及其困难的情况下，没有更合适的方式对程序作进一步修改，才创建分支。


## 15 持续交付管理

### 引言

企业治理：

CIMA：由董事会和执行管理层行使的一系列职责和实践，其目的是提供战略方向，确保企业达成目标，风险被合理的管理起来，并验证组织的资源被可靠地使用了。


### 配置与发布管理成熟度模型

实践：	构建管理和持续集成 | 

| 实践	        | 构建管理和持续集成 | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |


-1 阻碍的： 过程不可重复，受控性差，反作用的
0 重复性：过程被文档记录了，并有部分自动化
1 一致性：整个应用生命周期上使用自动化过程
2 量化管理：过程度量与控制
3 优化：聚焦于过程持续改进





## 主线改造计划

确定库列表（nuget）
确定组件列表


部署流水线的两个通用原则：快速反馈和为相关角色提供状态变化的可视化。
构建失败，哪个阶段失败，为何失败。

构建依赖图（库、组件）

主干开发模式的隐式要求：

- 持续集成保证（例如，有自动化测试保证）
- 代码结构良好（例如，组件化较好，集成相对平滑和容易）
- 开发人员有较高的要求（例如，有较好的持续集成实践基础，抽象代替分支的能力）



自动化测试保证良好的前提下： 主干开发模式
自动化测试不是很好的前提下： 分支开发模式

几个大的原则：

- 严格审视分支的创建
- 落实持续集成的相关实践
