# 版本管理

- 分支的引入
- 当前的代码结构和分支情况
- 我们面对的问题
- 如何操作

## 分支的引入

利用分支可以：

- 隔离影响（例如，满足多个团队对同一代码库的并行工作）
- 隔离变化（例如，引入发版分支和开发分支）
- 独立演化（例如，提取快照，引入定制项目分支）


但引入分支也会增加复杂性

- 学习、操作成本（例如，选择合适的分支策略，进行拉取，合并，删除等操作）
- 冲突处理（例如，并行开发的冲突，可能需要人为选择和干预）
- 工具的选择与依赖（例如，git和tfvc的不同设计思想，导致了不同的分支实践方案）

## 当前的代码结构和配置管理情况

我们的代码目前粗分为两类

- 共享库
    - 工具类库（ZQNB.Common）
    - 底层基础库(ZQNB.BaseLib)
    - 门户容器和后台管理(Portal, Space, Admin, AdminSg, AdminApp...)
    - 辅助工具(Tools)
- 应用模块
    - 主题定制(Themes)
    - 应用模块(ZQNB.Web.Areas.XYZ)

## 我们面对的问题

- 版本方案不理想
- 兼容性支持不好
- 分支策略可行性差
- 架构设计不友好
- 项目定制的含义模糊


缺乏版本方案
a.b.c.d

共享库部分：版本号不更新的问题（目前绝大部分1.0，永无更新）；兼容性（向后？向前？）如何定义和保证？
模块部分：独立演化还是一起演化（目前是一起更新的，GlobalAssemblyInfo.cs）；

统一概念
兼容性由Shared负责，所以应从Shared的视角看待兼容性：
3.1 Shared -> 3.1 FTC
3.2 Shared -> 3.2 FTC
3.1 Shared -> 3.2 FTC（向上兼容）
3.2 Shared -> 3.1 FTC（向下兼容）


兼容性计划（何种情况下支持或违反向下，向上？以及解决方案）
共享库之间： 互相支持向后兼容（3.2 Shared -> 3.1 Shared）


共享库向上兼容模块（难度太大暂予考虑）

共享库向下兼容模块
3.1 Shared -> 3.1 FTC
3.2 Shared -> 3.2 FTC
3.1 Shared -> 3.2 FTC（X）
3.2 Shared -> 3.1 FTC 

这种方案的优点：模块开发可以专注业务开发，安装升级逻辑相对简单
这种方案的缺点：Shared的接口约定需要持续保持OCP，有较大难度，不好落地，约定一旦被破坏，兼容性就得不到保证

共享库和模块之间同时演进（3.x Shared -> 3.x FTC）
3.1 Shared -> 3.1 FTC
3.2 Shared -> 3.2 FTC
3.1 Shared -> 3.2 FTC（X）
3.2 Shared -> 3.1 FTC（X）

这种方案的优点：兼容性的技术挑战相对少些，保持一定的发布频率，做好同版本间的兼容性测试即可
这种方案的缺点：模块和共享库的发版频率绑定，不够灵活

定制项目的方案参考
费用，人员，周期，升级问题

项目定制怎么办？真正有必要的项目定制分支，不在此考虑范围内？

Shared 

兼容的黄金主线，永远可发布，可兼容
master(最新的发布版，稳定，可用于发版候和演示部署。测试保障)
dev(最新的开发版，不稳定，不可用于发版候选和演示部署)

Master
release3.3
release3.3.1
release3.3.1-分支s

Modules（跟随Shared的模块部分）
2 
升级的兼容性问题
Shared内部不兼容
Area和Shared不兼容

3
如何看待拉分支？
如何对待定制需求？
如何对待公共库的完善和进化？
当前分支策略的执行注意事项？

可以落地的操作？
开发、测试、发布的计划（公共库部分，按一定的间隔周期？）
敏捷支持？重要接口的自动化测试？


项目的划分方案和版本管理粒度
基础库的演进和兼容性保证（2个纬度）
采用何种分支策略（一个问题的多个方面，如何拉分支，分别负责哪些任务，如何保持同步，分支的生命周期，策略的规则定义与遵守）
分支策略的选择，应考虑几个因素，可操作性，工具的影响，开发团队的因素，业务要求。
代码结构大致分两类，共享部分与模块部分。
新模块在哪个分支开发，基础库的演进应该在哪个分支开发，如何让不同的分支之间按需同步
基础库兼容性不好，带来的问题。
新模块，应该在哪个分支开发。
基础库在演进，怎么处理多个分支基础库的同步与兼容。
面临的问题



