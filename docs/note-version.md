# Version

- [What are differences between AssemblyVersion, AssemblyFileVersion and AssemblyInformationalVersion?](https://stackoverflow.com/questions/64602/what-are-differences-between-assemblyversion-assemblyfileversion-and-assemblyin)
- [What are the best practices for using Assembly Attributes?](https://stackoverflow.com/questions/62353/what-are-the-best-practices-for-using-assembly-attributes)
- [Setting Assembly Attributes](https://docs.microsoft.com/en-us/dotnet/framework/app-domains/set-assembly-attributes)

## 区别：

MSDN says:

    AssemblyVersion:
    Specifies the version of the assembly being attributed.

    AssemblyFileVersion:
    Instructs a compiler to use a specific version number for the Win32 file version resource. The Win32 file version is not required to be the same as the assembly's version number.

    AssemblyInformationalVersion:
    Defines additional version information for an assembly manifest.

## ProductVersion Apply Rule

AssemblyInformationalVersion -> AssemblyFileVersion -> AssemblyVersion

Note:
> Should be noted that for AssemblyInformationalVersion, if omitted, AssemblyFileVersion is used. Then AssemblyVersion if both are omitted.

###Windows Property Info:

FileVersion: AssemblyFileVersion -> AssemblyVersion
ProductVersion: AssemblyInformationalVersion -> AssemblyFileVersion -> AssemblyVersion

## Differents

### AssemblyVersion

Where other assemblies that reference your assembly will look. If this number changes, other assemblies have to update their references to your assembly! The AssemblyVersion is required.

I use the format: major.minor. This would result in:

[assembly: AssemblyVersion("1.0")]

### AssemblyFileVersion

Used for deployment. You can increase this number for every deployment. It is used by setup programs. Use it to mark assemblies that have the same AssemblyVersion, but are generated from different builds.

In Windows, it can be viewed in the file properties.

If possible, let it be generated by MSBuild. The AssemblyFileVersion is optional. If not given, the AssemblyVersion is used.

I use the format: major.minor.revision.build, where I use revision for development stage (Alpha, Beta, RC and RTM), service packs and hot fixes. This would result in:

[assembly: AssemblyFileVersion("1.0.3100.1242")]

### AssemblyInformationalVersion

The Product version of the assembly. This is the version you would use when talking to customers or for display on your website. This version can be a string, like '1.0 Release Candidate'.

Unfortunately, when you use a string, it will generate a false warning -- already reported to Microsoft (fixed in VS2010). Also the Code Analysis will complain about it (CA2243) -- reported to Microsoft (not fixed in VS2013).

The AssemblyInformationalVersion is optional. If not given, the AssemblyFileVersion is used.

I use the format: major.minor [revision as string]. This would result in:

[assembly: AssemblyInformationalVersion("1.0 RC1")]


## The .Net Way

### AssemblyVersion

The AssemblyVersion is the only version the CLR cares about (but it cares about the entire AssemblyVersion)

The AssemblyVersion is used by the CLR to bind to strongly named assemblies. It is stored in the AssemblyDef manifest metadata table of the built assembly, and in the AssemblyRef table of any assembly that references it.

This is very important, because it means that when you reference a strongly named assembly, you are tightly bound to a specific AssemblyVersion of that assembly. The entire AssemblyVersion must be an exact match for the binding to succeed. For example, if you reference version 1.0.0.0 of a strongly named assembly at build-time, but only version 1.0.0.1 of that assembly is available at runtime, binding will fail! (You will then have to work around this using Assembly Binding Redirection.)

### AssemblyFileVersion

The AssemblyFileVersion is intended to uniquely identify a build of the individual assembly

Typically you’ll manually set the Major and Minor AssemblyFileVersion to reflect the version of the assembly, then increment the Build and/or Revision every time your build system compiles the assembly. The AssemblyFileVersion should allow you to uniquely identify a build of the assembly, so that you can use it as a starting point for debugging any problems.

On my current project we have the build server encode the changelist number from our source control repository into the Build and Revision parts of the AssemblyFileVersion. This allows us to map directly from an assembly to its source code, for any assembly generated by the build server (without having to use labels or branches in source control, or manually keeping any records of released versions).

This version number is stored in the Win32 version resource and can be seen when viewing the Windows Explorer property pages for the assembly.


### AssemblyInformationalVersion

The AssemblyInformationalVersion is intended to represent the version of your entire product

The AssemblyInformationalVersion is intended to allow coherent versioning of the entire product, which may consist of many assemblies that are independently versioned, perhaps with differing versioning policies, and potentially developed by disparate teams.

“For example, version 2.0 of a product might contain several assemblies; one of these assemblies is marked as version 1.0 since it’s a new assembly that didn’t ship in version 1.0 of the same product. Typically, you set the major and minor parts of this version number to represent the public version of your product. Then you increment the build and revision parts each time you package a complete product with all its assemblies.” — Jeffrey Richter, CLR via C# (Second Edition) p. 57


### Think carefully about when you change your AssemblyVersion

The moral is that if you’re shipping assemblies that other developers are going to be referencing, you need to be extremely careful about when you do (and don’t) change the AssemblyVersion of those assemblies. Any changes to the AssemblyVersion will mean that application developers will either have to re-compile against the new version (to update those AssemblyRef entries) or use assembly binding redirects to manually override the binding.

Do not change the AssemblyVersion for a servicing release which is intended to be backwards compatible.
Do change the AssemblyVersion for a release that you know has breaking changes.
Just take another look at the version attributes on mscorlib:

	// Assembly mscorlib, Version 2.0.0.0
	[assembly: AssemblyVersion("2.0.0.0")]
	[assembly: AssemblyFileVersion("2.0.50727.3521")]
	[assembly: AssemblyInformationalVersion("2.0.50727.3521")]

Note that it’s the AssemblyFileVersion that contains all the interesting servicing information (it’s the Revision part of this version that tells you what Service Pack you’re on), meanwhile the AssemblyVersion is fixed at a boring old 2.0.0.0. Any change to the AssemblyVersion would force every .NET application referencing mscorlib.dll to re-compile against the new version!

Notes

> The CLR does not care about nor examine the AssemblyFileVersion or AssemblyInformationalVersion


## The ZQNB Way

	[assembly: AssemblyVersion("3.3.1.0")] //last updated at 2017-03-27 15:37:01
	[assembly: AssemblyFileVersion("3.3.6295.28110")] //last updated at 2017-03-27 15:37:01
	[assembly: AssemblyInformationalVersion("NbCloudFx V3.1")] //last updated at 2017-03-27 15:37:01


## The "Best" Way

todo
